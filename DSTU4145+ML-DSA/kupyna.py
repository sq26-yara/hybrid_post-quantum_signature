"""
Функція гешування ДСТУ 7564:2014 "Купина"
Повна реалізація для режиму Купина-256
"""

class Kupyna256:
    """
    Функція гешування Купина-256 згідно ДСТУ 7564:2014
    
    Параметри:
    - Розмір хешу: 256 біт (32 байт)
    - Внутрішній стан: 512 біт (64 байт)
    - Кількість ітерацій: 10
    - Колонок у матриці: 8
    """
    
    # S-box таблиці з ДСТУ 7564:2014 (Додаток А)
    SBOX = [
        # π₀ (S-box 0)
        [0xA8, 0x43, 0x5F, 0x06, 0x6B, 0x75, 0x6C, 0x59, 0x71, 0xDF, 0x87, 0x95, 0x17, 0xF0, 0xD8, 0x09,
         0x6D, 0xF3, 0x1D, 0xCB, 0xC9, 0x4D, 0x2C, 0xAF, 0x79, 0xE0, 0x97, 0xFD, 0x6F, 0x4B, 0x45, 0x39,
         0x3E, 0xDD, 0xA3, 0x4F, 0xB4, 0xB6, 0x9A, 0x0E, 0x1F, 0xBF, 0x15, 0xE1, 0x49, 0xD2, 0x93, 0xC6,
         0x92, 0x72, 0x9E, 0x61, 0xD1, 0x63, 0xFA, 0xEE, 0xF4, 0x19, 0xD5, 0xAD, 0x58, 0xA4, 0xBB, 0xA1,
         0xDC, 0xF2, 0x83, 0x37, 0x42, 0xE4, 0x7A, 0x32, 0x9C, 0xCC, 0xAB, 0x4A, 0x8F, 0x6E, 0x04, 0x27,
         0x2E, 0xE7, 0xE2, 0x5A, 0x96, 0x16, 0x23, 0x2B, 0xC2, 0x65, 0x66, 0x0F, 0xBC, 0xA9, 0x47, 0x41,
         0x34, 0x48, 0xFC, 0xB7, 0x6A, 0x88, 0xA5, 0x53, 0x86, 0xF9, 0x5B, 0xDB, 0x38, 0x7B, 0xC3, 0x1E,
         0x22, 0x33, 0x24, 0x28, 0x36, 0xC7, 0xB2, 0x3B, 0x8E, 0x77, 0xBA, 0xF5, 0x14, 0x9F, 0x08, 0x55,
         0x9B, 0x4C, 0xFE, 0x60, 0x5C, 0xDA, 0x18, 0x46, 0xCD, 0x7D, 0x21, 0xB0, 0x3F, 0x1B, 0x89, 0xFF,
         0xEB, 0x84, 0x69, 0x3A, 0x9D, 0xD7, 0xD3, 0x70, 0x67, 0x40, 0xB5, 0xDE, 0x5D, 0x30, 0x91, 0xB1,
         0x78, 0x11, 0x01, 0xE5, 0x00, 0x68, 0x98, 0xA0, 0xC5, 0x02, 0xA6, 0x74, 0x2D, 0x0B, 0xA2, 0x76,
         0xB3, 0xBE, 0xCE, 0xBD, 0xAE, 0xE9, 0x8A, 0x31, 0x1C, 0xEC, 0xF1, 0x99, 0x94, 0xAA, 0xF6, 0x26,
         0x2F, 0xEF, 0xE8, 0x8C, 0x35, 0x03, 0xD4, 0x7F, 0xFB, 0x05, 0xC1, 0x5E, 0x90, 0x20, 0x3D, 0x82,
         0xF7, 0xEA, 0x0A, 0x0D, 0x7E, 0xF8, 0x50, 0x1A, 0xC4, 0x07, 0x57, 0xB8, 0x3C, 0x62, 0xE3, 0xC8,
         0xAC, 0x52, 0x64, 0x10, 0xD0, 0xD9, 0x13, 0x0C, 0x12, 0x29, 0x51, 0xB9, 0xCF, 0xD6, 0x73, 0x8D,
         0x81, 0x54, 0xC0, 0xED, 0x4E, 0x44, 0xA7, 0x2A, 0x85, 0x25, 0xE6, 0xCA, 0x7C, 0x8B, 0x56, 0x80],
        
        # π₁ (S-box 1)
        [0xCE, 0xBB, 0xEB, 0x92, 0xEA, 0xCB, 0x13, 0xC1, 0xE9, 0x3A, 0xD6, 0xB2, 0xD2, 0x90, 0x17, 0xF8,
         0x42, 0x15, 0x56, 0xB4, 0x65, 0x1C, 0x88, 0x43, 0xC5, 0x5C, 0x36, 0xBA, 0xF5, 0x57, 0x67, 0x8D,
         0x31, 0xF6, 0x64, 0x58, 0x9E, 0xF4, 0x22, 0xAA, 0x75, 0x0F, 0x02, 0xB1, 0xDF, 0x6D, 0x73, 0x4D,
         0x7C, 0x26, 0x2E, 0xF7, 0x08, 0x5D, 0x44, 0x3E, 0x9F, 0x14, 0xC8, 0xAE, 0x54, 0x10, 0xD8, 0xBC,
         0x1A, 0x6B, 0x69, 0xF3, 0xBD, 0x33, 0xAB, 0xFA, 0xD1, 0x9B, 0x68, 0x4E, 0x16, 0x95, 0x91, 0xEE,
         0x4C, 0x63, 0x8E, 0x5B, 0xCC, 0x3C, 0x19, 0xA1, 0x81, 0x49, 0x7B, 0xD9, 0x6F, 0x37, 0x60, 0xCA,
         0xE7, 0x2B, 0x48, 0xFD, 0x96, 0x45, 0xFC, 0x41, 0x12, 0x0D, 0x79, 0xE5, 0x89, 0x8C, 0xE3, 0x20,
         0x30, 0xDC, 0xB7, 0x6C, 0x4A, 0xB5, 0x3F, 0x97, 0xD4, 0x62, 0x2D, 0x06, 0xA4, 0xA5, 0x83, 0x5F,
         0x2A, 0xDA, 0xC9, 0x00, 0x7E, 0xA2, 0x55, 0xBF, 0x11, 0xD5, 0x9C, 0xCF, 0x0E, 0x0A, 0x3D, 0x51,
         0x7D, 0x93, 0x1B, 0xFE, 0xC4, 0x47, 0x09, 0x86, 0x0B, 0x8F, 0x9D, 0x6A, 0x07, 0xB9, 0xB0, 0x98,
         0x18, 0x32, 0x71, 0x4B, 0xEF, 0x3B, 0x70, 0xA0, 0xE4, 0x40, 0xFF, 0xC3, 0xA9, 0xE6, 0x78, 0xF9,
         0x8B, 0x46, 0x80, 0x1E, 0x38, 0xE1, 0xB8, 0xA8, 0xE0, 0x0C, 0x23, 0x76, 0x1D, 0x25, 0x24, 0x05,
         0xF1, 0x6E, 0x94, 0x28, 0x9A, 0x84, 0xE8, 0xA3, 0x4F, 0x77, 0xD3, 0x85, 0xE2, 0x52, 0xF2, 0x82,
         0x50, 0x7A, 0x2F, 0x74, 0x53, 0xB3, 0x61, 0xAF, 0x39, 0x35, 0xDE, 0xCD, 0x1F, 0x99, 0xAC, 0xAD,
         0x72, 0x2C, 0xDD, 0xD0, 0x87, 0xBE, 0x5E, 0xA6, 0xEC, 0x04, 0xC6, 0x03, 0x34, 0xFB, 0xDB, 0x59,
         0xB6, 0xC2, 0x01, 0xF0, 0x5A, 0xED, 0xA7, 0x66, 0x21, 0x7F, 0x8A, 0x27, 0xC7, 0xC0, 0x29, 0xD7],
        
        # π₂ (S-box 2)
        [0x93, 0xD9, 0x9A, 0xB5, 0x98, 0x22, 0x45, 0xFC, 0xBA, 0x6A, 0xDF, 0x02, 0x9F, 0xDC, 0x51, 0x59,
         0x4A, 0x17, 0x2B, 0xC2, 0x94, 0xF4, 0xBB, 0xA3, 0x62, 0xE4, 0x71, 0xD4, 0xCD, 0x70, 0x16, 0xE1,
         0x49, 0x3C, 0xC0, 0xD8, 0x5C, 0x9B, 0xAD, 0x85, 0x53, 0xA1, 0x7A, 0xC8, 0x2D, 0xE0, 0xD1, 0x72,
         0xA6, 0x2C, 0xC4, 0xE3, 0x76, 0x78, 0xB7, 0xB4, 0x09, 0x3B, 0x0E, 0x41, 0x4C, 0xDE, 0xB2, 0x90,
         0x25, 0xA5, 0xD7, 0x03, 0x11, 0x00, 0xC3, 0x2E, 0x92, 0xEF, 0x4E, 0x12, 0x9D, 0x7D, 0xCB, 0x35,
         0x10, 0xD5, 0x4F, 0x9E, 0x4D, 0xA9, 0x55, 0xC6, 0xD0, 0x7B, 0x18, 0x97, 0xD3, 0x36, 0xE6, 0x48,
         0x56, 0x81, 0x8F, 0x77, 0xCC, 0x9C, 0xB9, 0xE2, 0xAC, 0xB8, 0x2F, 0x15, 0xA4, 0x7C, 0xDA, 0x38,
         0x1E, 0x0B, 0x05, 0xD6, 0x14, 0x6E, 0x6C, 0x7E, 0x66, 0xFD, 0xB1, 0xE5, 0x60, 0xAF, 0x5E, 0x33,
         0x87, 0xC9, 0xF0, 0x5D, 0x6D, 0x3F, 0x88, 0x8D, 0xC7, 0xF7, 0x1D, 0xE9, 0xEC, 0xED, 0x80, 0x29,
         0x27, 0xCF, 0x99, 0xA8, 0x50, 0x0F, 0x37, 0x24, 0x28, 0x30, 0x95, 0xD2, 0x3E, 0x5B, 0x40, 0x83,
         0xB3, 0x69, 0x57, 0x1F, 0x07, 0x1C, 0x8A, 0xBC, 0x20, 0xEB, 0xCE, 0x8E, 0xAB, 0xEE, 0x31, 0xA2,
         0x73, 0xF9, 0xCA, 0x3A, 0x1A, 0xFB, 0x0D, 0xC1, 0xFE, 0xFA, 0xF2, 0x6F, 0xBD, 0x96, 0xDD, 0x43,
         0x52, 0xB6, 0x08, 0xF3, 0xAE, 0xBE, 0x19, 0x89, 0x32, 0x26, 0xB0, 0xEA, 0x4B, 0x64, 0x84, 0x82,
         0x6B, 0xF5, 0x79, 0xBF, 0x01, 0x5F, 0x75, 0x63, 0x1B, 0x23, 0x3D, 0x68, 0x2A, 0x65, 0xE8, 0x91,
         0xF6, 0xFF, 0x13, 0x58, 0xF1, 0x47, 0x0A, 0x7F, 0xC5, 0xA7, 0xE7, 0x61, 0x5A, 0x06, 0x46, 0x44,
         0x42, 0x04, 0xA0, 0xDB, 0x39, 0x86, 0x54, 0xAA, 0x8C, 0x34, 0x21, 0x8B, 0xF8, 0x0C, 0x74, 0x67],
        
        # π₃ (S-box 3)
        [0x68, 0x8D, 0xCA, 0x4D, 0x73, 0x4B, 0x4E, 0x2A, 0xD4, 0x52, 0x26, 0xB3, 0x54, 0x1E, 0x19, 0x1F,
         0x22, 0x03, 0x46, 0x3D, 0x2D, 0x4A, 0x53, 0x83, 0x13, 0x8A, 0xB7, 0xD5, 0x25, 0x79, 0xF5, 0xBD,
         0x58, 0x2F, 0x0D, 0x02, 0xED, 0x51, 0x9E, 0x11, 0xF2, 0x3E, 0x55, 0x5E, 0xD1, 0x16, 0x3C, 0x66,
         0x70, 0x5D, 0xF3, 0x45, 0x40, 0xCC, 0xE8, 0x94, 0x56, 0x08, 0xCE, 0x1A, 0x3A, 0xD2, 0xE1, 0xDF,
         0xB5, 0x38, 0x6E, 0x0E, 0xE5, 0xF4, 0xF9, 0x86, 0xE9, 0x4F, 0xD6, 0x85, 0x23, 0xCF, 0x32, 0x99,
         0x31, 0x14, 0xAE, 0xEE, 0xC8, 0x48, 0xD3, 0x30, 0xA1, 0x92, 0x41, 0xB1, 0x18, 0xC4, 0x2C, 0x71,
         0x72, 0x44, 0x15, 0xFD, 0x37, 0xBE, 0x5F, 0xAA, 0x9B, 0x88, 0xD8, 0xAB, 0x89, 0x9C, 0xFA, 0x60,
         0xEA, 0xBC, 0x62, 0x0C, 0x24, 0xA6, 0xA8, 0xEC, 0x67, 0x20, 0xDB, 0x7C, 0x28, 0xDD, 0xAC, 0x5B,
         0x34, 0x7E, 0x10, 0xF1, 0x7B, 0x8F, 0x63, 0xA0, 0x05, 0x9A, 0x43, 0x77, 0x21, 0xBF, 0x27, 0x09,
         0xC3, 0x9F, 0xB6, 0xD7, 0x29, 0xC2, 0xEB, 0xC0, 0xA4, 0x8B, 0x8C, 0x1D, 0xFB, 0xFF, 0xC1, 0xB2,
         0x97, 0x2E, 0xF8, 0x65, 0xF6, 0x75, 0x07, 0x04, 0x49, 0x33, 0xE4, 0xD9, 0xB9, 0xD0, 0x42, 0xC7,
         0x6C, 0x90, 0x00, 0x8E, 0x6F, 0x50, 0x01, 0xC5, 0xDA, 0x47, 0x3F, 0xCD, 0x69, 0xA2, 0xE2, 0x7A,
         0xA7, 0xC6, 0x93, 0x0F, 0x0A, 0x06, 0xE6, 0x2B, 0x96, 0xA3, 0x1C, 0xAF, 0x6A, 0x12, 0x84, 0x39,
         0xE7, 0xB0, 0x82, 0xF7, 0xFE, 0x9D, 0x87, 0x5C, 0x81, 0x35, 0xDE, 0xB4, 0xA5, 0xFC, 0x80, 0xEF,
         0xCB, 0xBB, 0x6B, 0x76, 0xBA, 0x5A, 0x7D, 0x78, 0x0B, 0x95, 0xE3, 0xAD, 0x74, 0x98, 0x3B, 0x36,
         0x64, 0x6D, 0xDC, 0xF0, 0x59, 0xA9, 0x4C, 0x17, 0x7F, 0x91, 0xB8, 0xC9, 0x57, 0x1B, 0xE0, 0x61]
    ]
    
    # MDS матриця для MixColumns
    MDS_VECTOR = [0x01, 0x01, 0x05, 0x01, 0x08, 0x06, 0x07, 0x04]
    
    # Примітивний многочлен для GF(2^8): x^8 + x^4 + x^3 + x^2 + 1
    POLY = 0x11D
    
    def __init__(self):
        """Ініціалізація Купина-256"""
        self.state_size = 64  # 512 біт = 64 байт
        self.rounds = 10
        self.columns = 8
        self.rows = 8
        
        # Вектор ініціалізації для Купина-256
        self.iv = bytearray(64)
        self.iv[0] = 0x40  # 1 << 510 в little-endian
    
    def _add_constant_xor(self, state, round_num):
        """Додавання констант ітерацій за модулем 2 (для T⊕)"""
        for j in range(self.columns):
            state[j * 8] ^= ((j << 4) ^ round_num)
        return state
    
    def _add_constant_mod(self, state, round_num):
        """Додавання констант ітерацій за модулем 2^64 (для T+)"""
        for j in range(self.columns):
            # Константа для колонки j
            const = bytearray([0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
                              ((self.columns - 1 - j) << 4) ^ round_num])
            
            # Додавання за модулем 2^64
            carry = 0
            for i in range(8):
                idx = j * 8 + i
                sum_val = state[idx] + const[i] + carry
                state[idx] = sum_val & 0xFF
                carry = sum_val >> 8
        
        return state
    
    def _sub_bytes(self, state):
        """Нелінійна підстановка (S-box)"""
        result = bytearray(64)
        for i in range(64):
            sbox_idx = i % 4  # Вибір S-box (0, 1, 2, 3)
            result[i] = self.SBOX[sbox_idx][state[i]]
        return result
    
    def _shift_bytes(self, state):
        """Циклічний зсув рядків (праворуч) згідно ДСТУ 7564:2014.

        Внутрішній стан (I=512) інтерпретується як матриця 8×8 байтів, заповнена/зчитана
        **за колонками** (див. рисунок 2 стандарту).
        """
        res = bytearray(64)
        c = self.columns  # 8
        for row in range(8):
            shift = row if row < 7 else 7  # для I=512
            for col in range(c):
                src_col = (col - shift) % c  # зсув праворуч
                res[col * 8 + row] = state[src_col * 8 + row]
        return res

    def _gf_multiply(self, a, b):
        """Множення в GF(2^8) з примітивним многочленом 0x11D"""
        result = 0
        for _ in range(8):
            if b & 1:
                result ^= a
            high_bit = a & 0x80
            a <<= 1
            if high_bit:
                a ^= self.POLY
            a &= 0xFF
            b >>= 1
        return result
    
    def _mix_columns(self, state):
        """Лінійне перетворення ψ (MDS) над GF(2^8) згідно ДСТУ 7564:2014."""
        res = bytearray(64)
        u = self.MDS_VECTOR  # (01,01,05,01,08,06,07,04)
        c = self.columns
        for col in range(c):
            old = [state[col * 8 + r] for r in range(8)]
            for i in range(8):
                acc = 0
                # коефіцієнти (u >>> i): циклічний зсув праворуч вектора u
                for k in range(8):
                    coeff = u[(k - i) & 7]
                    acc ^= self._gf_multiply(coeff, old[k])
                res[col * 8 + i] = acc
        return res

    def _transform_xor(self, state, round_num):
        """Одна ітерація перетворення T⊕"""
        state = self._add_constant_xor(state, round_num)
        state = self._sub_bytes(state)
        state = self._shift_bytes(state)
        state = self._mix_columns(state)
        return state
    
    def _transform_add(self, state, round_num):
        """Одна ітерація перетворення T+"""
        state = self._add_constant_mod(state, round_num)
        state = self._sub_bytes(state)
        state = self._shift_bytes(state)
        state = self._mix_columns(state)
        return state
    
    def _xor_bytes(self, a, b):
        """XOR двох байтових масивів"""
        return bytearray(x ^ y for x, y in zip(a, b))
    
    def _pad_message(self, message):
        """Доповнення повідомлення"""
        msg_len = len(message)
        
        # Додаємо біт 1, потім нулі, потім довжину (96 біт = 12 байт)
        padded = bytearray(message)
        padded.append(0x80)  # Біт 1
        
        # Кількість нульових байтів
        block_size = self.state_size
        pad_len = (block_size - (len(padded) + 12) % block_size) % block_size
        padded.extend(b'\x00' * pad_len)
        
        # Довжина повідомлення в бітах (little-endian, 96 біт)
        bit_length = msg_len * 8
        padded.extend(bit_length.to_bytes(12, byteorder='little'))
        
        return padded
    
    def hash(self, message):
        """
        Обчислення хешу Купина-256
        
        Args:
            message: bytes - повідомлення для хешування
            
        Returns:
            bytes - хеш (32 байти)
        """
        # Доповнення
        padded = self._pad_message(message)
        
        # Поділ на блоки
        blocks = []
        for i in range(0, len(padded), self.state_size):
            blocks.append(padded[i:i + self.state_size])
        
        # Ініціалізація
        h = bytearray(self.iv)
        
        # Обробка блоків
        for block in blocks:
            # T⊕(h ⊕ m)
            temp = self._xor_bytes(h, block)
            for r in range(self.rounds):
                temp = self._transform_xor(temp, r)
            
            # T+(m)
            temp2 = bytearray(block)
            for r in range(self.rounds):
                temp2 = self._transform_add(temp2, r)
            
            # h = T⊕(h ⊕ m) ⊕ T+(m) ⊕ h
            h = self._xor_bytes(self._xor_bytes(temp, temp2), h)
        
        # Фінальне перетворення
        temp = bytearray(h)
        for r in range(self.rounds):
            temp = self._transform_xor(temp, r)
        
        h = self._xor_bytes(temp, h)
        
        # Повертаємо 256 біт (32 байти) - старші біти
        return bytes(h[32:64])
    
    def update(self, data):

        if not hasattr(self, '_buffer'):
            self._buffer = bytearray()
        self._buffer.extend(data)
    
    def digest(self):

        if not hasattr(self, '_buffer'):
            self._buffer = bytearray()
        return self.hash(bytes(self._buffer))
    
    def hexdigest(self):

        return self.digest().hex()


class KUPYNA256:
    
    def __init__(self):
        self._kupyna = Kupyna256()
        self._buffer = bytearray()
    
    def update(self, data):
        """Додати дані для хешування"""
        self._buffer.extend(data)
    
    def digest(self):
        """Отримати хеш"""
        return self._kupyna.hash(bytes(self._buffer))
    
    def hexdigest(self):
        """Отримати хеш у hex форматі"""
        return self.digest().hex()


# Для тестування
if __name__ == "__main__":
    # Тест 1: Порожнє повідомлення (N = 0)
    kupyna = Kupyna256()
    hash1 = kupyna.hash(b"")
    expected1 = "cd5101d1ccdf0d1d1f4ada56e888cd724ca1a0838a3521e7131d4fb78d0f5eb6"
    print(f"Тест 1 (N=0): {'' if hash1.hex() == expected1 else ''}")
    print(f"Отримано:  {hash1.hex()}")
    print(f"Очікується: {expected1}\n")
    
    # Тест 2: Одни байт (N = 8)
    hash2 = kupyna.hash(b"\xFF")
    expected2 = "ea7677ca4526555680441c117982ea14059ea6d0d7124d6ecdb3deec49e890f4"
    print(f"Тест 2 (N=8): {'' if hash2.hex() == expected2 else ''}")
    print(f"Отримано:  {hash2.hex()}")
    print(f"Очікується: {expected2}\n")
    
    # Тест 3: 512 біт
    test_data = bytes(range(64))
    hash3 = kupyna.hash(test_data)
    expected3 = "08f4ee6f1be6903b324c4e27990cb24ef69dd58dbe84813ee0a52f6631239875"
    print(f"Тест 3 (N=512): {'' if hash3.hex() == expected3 else ''}")
    print(f"Отримано:  {hash3.hex()}")
    print(f"Очікується: {expected3}")
